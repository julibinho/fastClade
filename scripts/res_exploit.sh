#reformate and then compute the result file, it calculate the Succes, False positiv and True negativ based on their family




#test on arguments
#test if the result all vs all input file is correct
if [ "$1" == "-r" ] && [ -n "$2" ] && [ -f "$2" ] ; then result_file_check=true ;  fi

#test if the test list input file is correct
if [ "$3" == "-t" ] && [ -n "$4" ] && [ -f "$4" ] ; then test_input_check=true ; fi

#test if the reference input file is correct 
if [ "$5" == "-b" ] && [ -n "$6" ] && [ -f "$6" ] ; then ref_input_check=true ; fi


training_list=$6;
result_list=$2;
test_list=$4;



#d1hxs le soucis


#if all the tests are true, we execute de command line
if [ -e `pwd`/temp_file2.txt ]  ; then rm `pwd`/temp_file2.txt ; fi
if [ "$result_file_check" == true ] && [ "$test_input_check" == true ] && [ "$ref_input_check" == true ]; 
	then 

	###start of result formating
	start2=$SECONDS;
	# note : here, we do an egrep -v because this sequence specificaly ruin the test, i need to found a way to solve this
 
	#we first sort the fasta, like that, we have all the score of the same fasta located at the same spot, it allow a faster computation of the file 
	#complexity in O(sort)+O(x) , insted of O(x**) if for eache pssm, we need to check all the result file

	sort -k2 $result_list | egrep -v "d1hxs" | awk '	
		#au begin, on initialise les champs => evite les 0 0 au debut du fichier
		BEGIN{current_fasta=$2 ; best_score=$12 ; best_pssm=$1}

		#lors que l on change de fasta que l on traite, alors on affiche les donnes recoltes : [FASTA] [SCORE] [PSSM] et on effectue le changement de fasta
		{if(current_fasta!=$2) {{print current_fasta" "best_score" "best_pssm}{current_fasta=$2 ; best_score=$12 ; best_pssm=$1}}
		
		#update du score et du pssm si jamais
		{if(best_score<$12) {{best_score=$12} {best_pssm=$1}}} 
	}' >> temp_file2.txt

	duration2=$(( SECONDS - start2 ))	
	echo "result formating done in $duration2 second(s)" ;
	###end of result formating



	###start of computing result
	result_list=`pwd`/temp_file2.txt
	#result_list=$temp_file2;
	start3=$SECONDS;


	succes=0;
	FP=0;
	FN=0;
	#get the fasta name and the family name
	for i in `cat $result_list | awk '{print $1}'`;

		#on met dans famille_fasta, la famille de la fasta que l'on recupère de la liste test
		do famille_fasta=`cat $test_list | awk -v current_fasta="$i" '{if (current_fasta==$1) {print $4}}'` ;
		
		#on met dans pssm, le meilleur pssm du fasta actuel que l'on recupère de la liste result
		current_pssm=`cat $result_list | awk -v current_fasta="$i" '{if (current_fasta==$1) {print $3}}'`; #quand le champ est vide : affiche erreure
		
		#on cherche la famille du pssm que l'on recupère de la liste train 
		famille_pssm=`cat $training_list | awk -v current_pssm="$current_pssm" '{if (current_pssm==$1) {print $3}}'`;

		#echo $famille_fasta " " $famille_pssm;
		if [ "$famille_fasta" == "$famille_pssm" ] ; then succes=$(($succes+1))  ; else if [ -z "$famille_fasta" ] ;then FN=$(($FN+1))  ;
		
	else FP=$(($FP+1)) ; fi ; fi ;
	
	#la plupart des False Negatif (tous acutellement) sont du à PSIBLAST qui change la syntax de la séquence pssm, et entraine une mauvaise reconnaissance dans cet algorithme
	done;
	rm $result_list
	echo succes : $succes        FP : $FP                 FN : $FN	
	duration3=$(( SECONDS - start3 ))	
	echo "result computation done in $duration3 second(s)" ;

else 
	#when "-help" isn't explicitly inputed, it show which argument was wrong
	if [ "$result_file_check" != true ] && [ "$#" != "0" ] && [ "$1" != "-help" ] ; then echo "result file input is incorrect, type \"-help\" for more informations" ;  fi
	if [ "$test_input_check" != true ] && [ "$#" != "0" ] && [ "$1" != "-help" ] ; then echo "test file input is invalid, type \"-help\" for more informations" ; fi
	if [ "$ref_input_check" != true ] && [ "$#" != "0" ] && [ "$1" != "-help" ] ; then echo "the reference list is incorect, type \"-help\" for more informations" ; fi 
	
fi ;



#if "-help" has been explicitly inputted, it shows the help, as when nothing is inputted
if [ "$#" == "0" ] || [ "$1" == "-help" ] ; then echo "
This bash script is used to format the all to all result, and then, computing the number of succes, false positiv, and true negatif.

The first argument -r must be the all_vs_all result file.
the second argument -t must be the test list that contain test fasta. 
The third argument -b must bbe the reference list that contain the pssm list with each family renseigned.

Typical usage of the script :
./res_exploit.sh -r result_all_vs_all -t test_dataset.list_family -b train_dataset.list" ; fi
















